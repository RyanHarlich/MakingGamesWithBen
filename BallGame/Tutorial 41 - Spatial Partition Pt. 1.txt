Updated Files:
		- BallController.cpp
		- BallController.h
		- Added Grid.cpp
		- Added Grid.h
		- MainGame.cpp
		- MainGame.h
		- Ball.h

___________________________________________________________________________________
Notes:
		- Last lesson could not process 4000 balls without dropping to 2fps, should easily be able to
				- The problem is each ball has to do collision with 3999 other balls!
		- This lesson will be doing 10,000 balls! With spatial partition

		- Spatial Partition: improve performance of games that have lots of objects
				- if do not need it, do not do it because it is difficult to write and can hurt performance
			- Spatial: in space
			- Partition: spliting into parts

		- In .png attached picture, balls are in a grid space (spatial partition)
				- if the red ball is so far away from blue ball does not make sense to check for collision
				- does not make sense to check red ball with 10000 other balls
				- instead only check red ball for collision in its own grid space (its own square)
						- already there is an improvement of not checking any balls
						- ALSO! if on a grid line it is in the box  that its orgin is in, the second red ball added for the next explanation does not check the box that its right side is in
		- Grid
			- Should be bigger than the diameter of the biggest ball
			- Not only does the ball check its own box, but it checks its own box, the box above, the top left box, the left box, and the bottom left box to form an L. This avoids redundancy checking
					- if adding another red and purple ball can see that the red ball does not check for the purple ball but the purple ball does check the red ball

		- If have a bunch of different classes that can all collide together
			- should all have some base class that they inherit from for a grid and spatial partition
			- store pointers in here (the grid or box) for collision

		- Grid is probably only for collision checks, unless there is something else it can maximize performance and be useful

		- use a seperate list for movement, not the grid




		/* NEW: nothing was changed! But pointing out that if a pointer to a ball in a vector was pointing to one, and the vector changed, the pointer would lose the ball and no longer be pointing to that ball because as a vector changes it shifts around in memory and changes, this following line will prevent that from happening because the vector has been sized and would not be resized later unless done so, so its spot in memory will not change */