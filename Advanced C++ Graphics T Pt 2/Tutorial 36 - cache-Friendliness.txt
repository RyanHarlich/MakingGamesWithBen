Updated Files:
		- No files, only a picture and notes
___________________________________________________________________________________
Notes:
	Computer Science Tutorial
		- CPU (Central Processing Unit)
				- Where all code runs, brain of computer
		- Cache
				- Speed of access of variables in RAM
				- Small version of RAM
				- Hold things from RAM so it can be accessed quickly
				- Cache has 3 levels:
					- L1: Smallest and closest to CPU
					- L2: 
					- L3: Biggest
				- Way faster to access Cache than to access RAM because it is smaller and very close to the CPU.
				- How it works:
					- When getting a heap variable, the CPU will ask that cache if that data is here, if not it will fetch it from the RAM and then write it to the cache, but not only the one variable. Instead it writes an entire cache line which is typically 64 bytes. So if variable is 8 bytes, it will grab the 64 bytes around that variable, and write it to the cache in a cache line. From here the cache returns only that one variable, in this case only the 8 bytes, backup to the CPU.
				- The reason:
					- The data is in contiguous memory. 
				- Example:
					- If asking for the first element of an array. Will ask cache which will ask RAM (which is slow) and will grab the first element through the 64th element write it to the cahce and send only the first element to the CPU. Now when the CPU ask for the second element it will ask the cache which will not ask the RAM because the RAM already wrote the 64bits of memory to the cache. So to get the second element will be a lot faster, because the cache is faster than the RAM.
							- When grabing the 65th element, the process will have to repeat because the 65th element was not written to the cache in the cache line, so it will have to fetch it from RAM again and write another 64 bytes to the cache again in a cache line.
				- Conclusion:
					- The process of grabbing heap variables is alot faster with the cache than grabbing straight from the RAM.
				- Relation:
					- It would be like the librarian walking back and forwards to grab all the Harry Potter books one at the time if the cache did not exist. With the cache there, it would be that the librarian assumed that since the reader checked out the first book, the reader would read the whole series, so instead of walking back and forwards the librarian grabbed the whole series at once and stashed them close by.
				- What is cache friendly?
					- If making a pointer to a new dynamically sized array it would be one contiguous memory so it would be cache friendly.
					- Resizing a vector of pointers is not a cache thing because only the pointers are allocated and not the pointer's memory.
					- Using the key word new in a loop to allocate the blocks of memory is not cache friendly because it does not guareente that the memory is contiguous, so when grabbing 64 bytes it could end up only grabing one objects because all the new objects were scattered in memory.
						- Make sure memory is in contiguous buffers. The program is probably written wrong if using a loop and the key word new a bunch.

		- RAM (Random Access Memory)
				- Variables stored on the heap
				- Accessing something in RAM is very slow, compared to hard disk it is actually fast

